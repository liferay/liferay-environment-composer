import com.liferay.docker.workspace.environments.Util

import groovy.json.JsonSlurper

import java.time.format.DateTimeFormatter

plugins {
	id "com.avast.gradle.docker-compose" version "0.17.10"
	id "docker-common"
	id "docker-database-saas"
	id "docker-liferay-bundle"
	id "docker-webserver"
}

if (Boolean.getBoolean("env.mode.ci")) {
	formatSource {
		failOnAutoFix = true
	}
}

gradle.liferayWorkspace {
	dockerImageId = config.liferayDockerImageId
}

Instant now = Instant.now()

DateTimeFormatter formatter = DateTimeFormatter.
ofPattern("yyyyMMdd.HHmmss").
withZone(ZoneId.systemDefault())

String timestamp = formatter.format(now)

tasks.register("exportContainerData") {
	doFirst {
		String hostPath = projectDir.relativePath(file("exported_data/data_${config.namespace}_${timestamp}"))

		getExistingVolumeNames().each {
			String volumeName ->

			String backupFileName = "${volumeName.substring(config.namespace.length() + 1)}.tar"

			if (backupFileName.equals("dumps.tar")) {
				return
			}

			println "Creating backup of volume ${volumeName} in ${hostPath}/${backupFileName}"
			waitForCommand("docker run --rm -v ${volumeName}:/source -v ${hostPath}:/target busybox:latest tar --create --file=/target/${backupFileName} --directory=/source .")
			println "Created backup of volume ${volumeName} in ${hostPath}/${backupFileName}"
		}

		updateGradleLocalProperties(["lr.docker.environment.data.directory" : hostPath])

		logger.lifecycle("\nUpdated gradle-local.properties with the new value:\nlr.docker.environment.data.directory=${hostPath}")
	}
}

tasks.register("importContainerData") {
	mustRunAfter ":buildDockerImage"

	doFirst {
		List<String> previousVolumeNames = getExistingVolumeNames()

		waitForCommand("docker compose build")
		waitForCommand("docker compose create")

		List<String> currentVolumeNames = getExistingVolumeNames()

		project.file(config.dataDirectory).listFiles().each {
			File backupFile ->

			if (backupFile.isFile() && !backupFile.name.endsWith(".tar")) {
				return
			}

			String volumeName = "${config.namespace}_${backupFile.name}"

			if (backupFile.isFile()) {
				volumeName = volumeName.substring(0, volumeName.length() - 4)
			}

			if (!currentVolumeNames.contains(volumeName)) {
				return
			}

			if (previousVolumeNames.contains(volumeName)) {
				return
			}

			println "Restoring backup of volume ${volumeName} using ${backupFile.absolutePath}"

			if (backupFile.isFile()) {
				waitForCommand("docker run --rm -v ${volumeName}:/target -v ${backupFile.absolutePath}:/source.tar busybox:latest tar --extract --file=/source.tar --directory=/target/")
			}
			else {
				waitForCommand("docker run --rm -v ${volumeName}:/target -v ${backupFile.absolutePath}:/source busybox:latest sh -c 'cp --update --recursive /source/* /target/'")
			}

			println "Restored backup of volume ${volumeName} using ${backupFile.absolutePath}"

			println waitForCommand("docker run --rm -v ${volumeName}:/${volumeName} busybox:latest du -sh /${volumeName}/")
		}
	}
}

tasks.register("importDocumentLibraryStructure") {
	doLast {
		project.fileTree(project.getProperty("sourceDir")).visit {
			if (it.isDirectory()) {
				return
			}

			File newFile = project.file("configs/common/data/document_library/${it.relativePath}")

			if (!newFile.parentFile.exists()) {
				newFile.parentFile.mkdirs()
			}

			if (!newFile.exists()) {
				newFile.createNewFile()
			}
		}
	}
}

tasks.register("shareWorkspace") {
	doLast {
		String fileListFileName = "shared_workspaces/workspace_${config.namespace}_${timestamp}.txt"
		String archiveFileName = "shared_workspaces/workspace_${config.namespace}_${timestamp}.zip"

		file(fileListFileName).text = fileTree('.') {
			exclude ".gitkeep"
			exclude ".gitignore"
			exclude ".git"
			exclude ".gradle"
			exclude "binds"
			exclude "buildSrc/build"
			exclude "buildSrc/.gradle"
			exclude "dumps/*"
			exclude "shared_workspaces"
			exclude {
				FileTreeElement fileTreeElement ->

				fileTreeElement.relativePath.pathString.startsWith("exported_data/") &&
				!fileTreeElement.relativePath.pathString.startsWith(config.dataDirectory)
			}

			include "${config.dataDirectory}/**"
			include "**/*"
		}.files.collect {
			File file ->

			project.relativePath(file)
		}.join("\n")

		try {
			waitForCommand("7z a -bsp2 ${archiveFileName} -i@${fileListFileName}")
		}
		finally {
			file(fileListFileName).delete()
		}
	}
}

tasks.register("restart") {
	dependsOn ":start"
	dependsOn ":stop"
}

tasks.register("start") {
	dependsOn ":composeUp"
	mustRunAfter ":stop"
}

tasks.register("stop") {
	dependsOn ":composeDown"
}

buildDockerImage {
	doFirst {
		waitForCommand("docker pull ${gradle.liferayWorkspace.dockerImageLiferay}", null, System.out)
	}

	onlyIf("using the Liferay service") {
		config.useLiferay
	}

	dependsOn ":checkForLiferayLicense"
	dependsOn ":prepareJDBCDriver"

	mustRunAfter ":importDatabaseDumps"
}

clean {
	dependsOn ":cleanPrepareJDBCDriver"
	dependsOn ":cleanPrepareHotfixes"
	dependsOn ":cleanPrepareSelfSignedCert"
	dependsOn ":cleanPrepareWebserverConfig"
	dependsOn ":cleanDownloadYourKitAgentZip"
	dependsOn ":cleanPrepareYourKitAgent"
}

dockerDeploy {
	dependsOn ":prepareJDBCDriver"
	dependsOn ":prepareHotfixes"
	dependsOn ":prepareYourKitAgent"
}

composeBuild {
	dependsOn ":prepareSelfSignedCert"
	dependsOn ":prepareWebserverConfig"
}

composeUp {
	onlyIf("there are Compose files") {
		!config.composeFiles.isEmpty()
	}

	dependsOn ":buildDockerImage"
	dependsOn ":importContainerData"
	dependsOn ":importDatabaseDumps"

	doFirst {
		println "Using config:\n\n${config}\n\n"
	}

	finalizedBy ":listAdminUsers"
	finalizedBy ":printBundleInfo"
}

Map<String, String> environmentMap = [:]

environmentMap.put "DATA_DIRECTORY", config.dataDirectory
environmentMap.put "DATABASE_NAME", config.databaseName
environmentMap.put "GLOWROOT_ENABLED", config.glowrootEnabled
environmentMap.put "NAMESPACE", config.namespace

if (config.useClustering) {
	environmentMap.put "LIFERAY_CLUSTER_NODES", config.clusterNodes
}

if (config.useLiferay) {
	environmentMap.put "LIFERAY_IMAGE_NAME", config.liferayDockerImageId
}

environmentMap.put("COMPOSE_FILE", config.composeFiles.join(File.pathSeparator))
environmentMap.put("COMPOSE_PROJECT_NAME", config.namespace)

file("ports.env").withInputStream {
	portsFile ->

	Properties ports = new Properties()

	ports.load(portsFile)

	environmentMap.putAll ports
}

file('.env').withOutputStream {
	BufferedOutputStream envFileOutputStream ->

	environmentMap.forEach {
		key, value ->

		envFileOutputStream << key << "=" << value << "\n"
	}
}

dockerCompose {
	captureContainersOutput = true
	environment.putAll environmentMap
	projectName = config.namespace
	removeVolumes = config.clearVolumeData
	useComposeFiles = config.composeFiles
	waitForTcpPorts = false

	// DEBUG: Set to true if container startup is failing
	retainContainersOnStartupFailure = false
}