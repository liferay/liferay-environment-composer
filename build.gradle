import com.liferay.docker.workspace.environments.Util

import groovy.json.JsonSlurper

import java.time.format.DateTimeFormatter

plugins {
	id "com.avast.gradle.docker-compose" version "0.17.10"
	id "docker-common"
	id "docker-database-saas"
	id "docker-liferay-bundle"
}

if (Boolean.getBoolean("env.mode.ci")) {
	formatSource {
		failOnAutoFix = true
	}
}

gradle.liferayWorkspace {
	dockerImageId = config.liferayDockerImageId
}

Instant now = Instant.now()

DateTimeFormatter formatter = DateTimeFormatter.
ofPattern("yyyyMMdd.HHmmss").
withZone(ZoneId.systemDefault())

String timestamp = formatter.format(now)

tasks.register("exportContainerData") {
	doFirst {
		List<String> existingVolumeNames = getExistingVolumeNames()

		if (existingVolumeNames.isEmpty()) {
			println "There is no data to export. Skipping."

			return
		}

		File exportDir = file("exported_data/data_${config.namespace}_${timestamp}")

		String hostPath = projectDir.relativePath(exportDir)

		existingVolumeNames.each {
			String volumeName ->

			String backupFileName = "${volumeName.substring(config.namespace.length() + 1)}.tar"

			if (backupFileName.equals("dumps.tar")) {
				return
			}

			println "Creating backup of volume ${volumeName} in ${hostPath}/${backupFileName}"
			waitForCommand("docker run --rm -v ${volumeName}:/source -v ${exportDir.absolutePath}:/target busybox:latest tar --create --file=/target/${backupFileName} --directory=/source .")
		}

		updateGradleLocalProperties(["lr.docker.environment.data.directory" : hostPath])

		logger.lifecycle("\nUpdated gradle-local.properties with the new value:\nlr.docker.environment.data.directory=${hostPath}")
	}
}

tasks.register("printWebserverConfig") {
	onlyIf("using a webserver") {
		config.useWebserver
	}

	doFirst {
		println waitForCommand("docker exec ${config.namespace}-webserver nginx -T")
	}
}

tasks.register("importContainerData") {
	dependsOn ":buildDockerImage"

	doFirst {
		List<String> previousVolumeNames = getExistingVolumeNames()

		waitForCommand("docker compose build")
		waitForCommand("docker compose create")

		List<String> currentVolumeNames = getExistingVolumeNames()

		project.file(config.dataDirectory).listFiles().each {
			File backupFile ->

			if (backupFile.isFile() && !backupFile.name.endsWith(".tar")) {
				return
			}

			String volumeName = "${config.namespace}_${backupFile.name}"

			if (backupFile.isFile()) {
				volumeName = volumeName.substring(0, volumeName.length() - 4)
			}

			if (!currentVolumeNames.contains(volumeName)) {
				return
			}

			if (previousVolumeNames.contains(volumeName)) {
				return
			}

			println "Restoring backup of volume ${volumeName} using ${backupFile.absolutePath}"

			if (backupFile.isFile()) {
				waitForCommand("docker run --rm -v ${volumeName}:/target -v ${backupFile.absolutePath}:/source.tar busybox:latest tar --extract --file=/source.tar --directory=/target/")
			}
			else {
				waitForCommand("docker run --rm -v ${volumeName}:/target -v ${backupFile.absolutePath}:/source busybox:latest sh -c 'cp --update --recursive /source/* /target/'")
			}

			["liferay": 1000, "sqlserver": 10001 ].each {
				entry ->
				int port = entry.value
				String serviceName = entry.key

				if (volumeName.endsWith("_${serviceName}")) {
					println "Setting volume permissions for service ${serviceName} to user/group ${port}"

					waitForCommand("docker run --rm -v ${volumeName}:/target busybox:latest sh -c 'chown -R ${port}:${port} /target'")
				}
			}

			println waitForCommand("docker run --rm -v ${volumeName}:/${volumeName} busybox:latest du -sh /${volumeName}/")
		}
	}
}

tasks.register("importDocumentLibraryStructure") {
	doLast {
		project.fileTree(project.getProperty("sourceDir")).visit {
			if (it.isDirectory()) {
				return
			}

			File newFile = project.file("configs/common/data/document_library/${it.relativePath}")

			if (!newFile.parentFile.exists()) {
				newFile.parentFile.mkdirs()
			}

			if (!newFile.exists()) {
				newFile.createNewFile()
			}
		}
	}
}

tasks.register("shareWorkspace7z") {
	doLast {
		if (!isProgramInstalled("7z")) {
			throw new GradleException("The 7z CLI must be installed in order to share workspaces. Follow the install instructions at https://7-zip.org/download.html.")
		}

		String fileListFileName = "shared_workspaces/workspace_${config.namespace}_${timestamp}.txt"
		String archiveFileName = "shared_workspaces/workspace_${config.namespace}_${timestamp}.7z"

		File fileListFile = file(fileListFileName)

		fileListFile.parentFile.mkdirs()

		fileListFile.text = fileTree('.') {
			exclude ".gitkeep"
			exclude ".gitignore"
			exclude ".git"
			exclude ".gradle"
			exclude "binds"
			exclude "buildSrc/build"
			exclude "buildSrc/.gradle"
			exclude "dumps/*"
			exclude "shared_workspaces"
			exclude {
				FileTreeElement fileTreeElement ->

				fileTreeElement.relativePath.pathString.startsWith("exported_data/") &&
				!fileTreeElement.relativePath.pathString.startsWith(config.dataDirectory)
			}

			include "${config.dataDirectory}/**"
			include "**/*"
		}.files.collect {
			File file ->

			project.relativePath(file)
		}.join("\n")

		try {
			waitForCommand("7z a -m0=lzma2 -mx=1 -bsp2 ${archiveFileName} -i@${fileListFileName}")
		}
		finally {
			fileListFile.delete()
		}

		println "New workspace archive file: ${archiveFileName}"
	}
}

tasks.register("shareWorkspaceZip", Zip) {
	archiveFileName = provider {
		"workspace_${config.namespace}_${timestamp}.zip"
	}

	destinationDirectory = file 'shared_workspaces'

	doLast {
		logger.lifecycle "\nWorkspace zip: ${archiveFile.get()}\n"
	}

	exclude ".gitkeep"
	exclude ".gitignore"
	exclude ".git"
	exclude ".gradle"
	exclude "binds"
	exclude "buildSrc/build"
	exclude "buildSrc/.gradle"
	exclude "dumps/*"
	exclude "shared_workspaces"
	exclude {
		FileTreeElement fileTreeElement ->

		fileTreeElement.relativePath.pathString.startsWith("exported_data/") &&
		!fileTreeElement.relativePath.pathString.startsWith(config.dataDirectory)
	}

	from '.'

	include "${config.dataDirectory}/**"
	include "**/*"

	outputs.upToDateWhen {
		false
	}

	zip64 = true
}

tasks.register("shareWorkspace") {
	if (isProgramInstalled("7z")) {
		dependsOn ":shareWorkspace7z"
	}
	else {
		dependsOn ":shareWorkspaceZip"
	}
}

tasks.register("restart") {
	dependsOn ":start"
	dependsOn ":stop"
}

tasks.register("start") {
	dependsOn ":composeUp"
	mustRunAfter ":stop"
}

tasks.register("stop") {
	dependsOn ":composeDown"
}

buildDockerImage {
	doFirst {
		waitForCommand("docker pull ${gradle.liferayWorkspace.dockerImageLiferay}", null, System.out)
	}

	onlyIf("using the Liferay service") {
		config.useLiferay
	}

	dependsOn ":checkForLiferayLicense"
	dependsOn ":prepareJDBCDriver"
	dependsOn ":prepareSAXParser"

	mustRunAfter ":importDatabaseDumps"
}

clean {
	dependsOn ":cleanPrepareJDBCDriver"
	dependsOn ":cleanPrepareHotfixes"
	dependsOn ":cleanPrepareSAXParser"
	dependsOn ":cleanPrepareXugglerJar"
	dependsOn ":cleanDownloadYourKitAgentZip"
	dependsOn ":cleanPrepareYourKitAgent"
}

dockerDeploy {
	dependsOn ":prepareJDBCDriver"
	dependsOn ":prepareHotfixes"
	dependsOn ":prepareSAXParser"
	dependsOn ":prepareXugglerJar"
	dependsOn ":prepareYourKitAgent"
}

composeUp {
	onlyIf("there are Compose files") {
		!config.composeFiles.isEmpty()
	}

	dependsOn ":buildDockerImage"
	dependsOn ":importContainerData"
	dependsOn ":importDatabaseDumps"

	doFirst {
		println "Using config:\n\n${config}\n\n"
	}

	finalizedBy ":listAdminUsers"
	finalizedBy ":printBundleInfo"
	finalizedBy ":printWebserverConfig"
}

Map<String, String> environmentMap = [:]

environmentMap.put "DATA_DIRECTORY", config.dataDirectory
environmentMap.put "DATABASE_NAME", config.databaseName
environmentMap.put "NAMESPACE", config.namespace

if (config.useClustering) {
	environmentMap.put "LIFERAY_CLUSTER_NODES", config.clusterNodes
}

if (config.useLiferay) {
	environmentMap.put "LIFERAY_IMAGE_NAME", config.liferayDockerImageId
}

environmentMap.put("COMPOSE_FILE", config.composeFiles.join(File.pathSeparator))
environmentMap.put("COMPOSE_PROJECT_NAME", config.namespace)

String validDLStoreTypes = "advanced,db,s3,simple"

if (!validDLStoreTypes.contains(config.dlStore)) {
	throw new GradleException("Invalid DL store type provided. Please see gradle.properties file for valid store types.")
}

if (config.dlStore == "advanced") {
	environmentMap.put("DL_STORE_PATH", config.dlStorePath)
}

if (config.dlStore == "s3") {
	environmentMap.put("S3_ACCESS_KEY", config.s3AccessKey)
	environmentMap.put("S3_BUCKET_NAME", config.s3BucketName)
	environmentMap.put("S3_REGION", config.s3Region)
	environmentMap.put("S3_SECRET_KEY", config.s3SecretKey)
}

environmentMap.put("DL_STORE_CLASS", config.dlStoreClass)

environmentMap.put("MEDIA_PREVIEW_ENABLED", config.mediaPreviewEnabled)

file("ports.env").withInputStream {
	portsFile ->

	Properties ports = new Properties()

	ports.load(portsFile)

	environmentMap.putAll ports
}

if (config.useClustering) {
	environmentMap.put("WEBSERVER_UPSTREAM_FILE", "upstream.cluster.conf")
}

if (config.useWebserver) {
	environmentMap.put("WEBSERVER_HOSTNAMES", config.webserverHostnames)
	environmentMap.put("MODSECURITY_ENABLED", config.modSecurityEnabled)
	environmentMap.put("WEBSERVER_PROTOCOL", config.webserverProtocol)
	environmentMap.put("WEBSERVER_PROTOCOL_UPPERCASE", config.webserverProtocol.toUpperCase())

	if (config.webserverProtocol == "http") {
		environmentMap.put("WEBSERVER_CONTAINER_PORT", "80")
		environmentMap.put("WEBSERVER_HOST_PORT", environmentMap["WEBSERVER_HTTP_PORT"])
	}

	if (config.webserverProtocol == "https") {
		environmentMap.put("WEBSERVER_CONTAINER_PORT", "443")
		environmentMap.put("WEBSERVER_HOST_PORT", environmentMap["WEBSERVER_HTTPS_PORT"])
	}
}

file("versions.env").withInputStream {
	versionsFile ->

	Properties versions = new Properties()

	versions.load(versionsFile)

	environmentMap.putAll versions
}

file('.env').withOutputStream {
	BufferedOutputStream envFileOutputStream ->

	environmentMap.forEach {
		key, value ->

		envFileOutputStream << key << "=" << value << "\n"
	}
}

dockerCompose {
	captureContainersOutput = true
	environment.putAll environmentMap
	projectName = config.namespace
	removeVolumes = config.clearVolumeData
	useComposeFiles = config.composeFiles
	waitForTcpPorts = false

	// DEBUG: Set to true if container startup is failing
	retainContainersOnStartupFailure = false
}