import com.liferay.docker.workspace.environments.Config
import com.liferay.docker.workspace.environments.Util

import groovy.json.JsonSlurper

ext {
	config = new Config(project)

	addToVolume = {
		String volumeName, File sourceFile ->

		String sourcePath = sourceFile.absolutePath

		if (!sourceFile.exists()) {
			throw new GradleException("Unable to find file ${sourcePath}")
		}

		String targetName = sourceFile.name

		println "Copying file ${sourcePath} to ${volumeName}"
		waitForCommand("docker run --rm -v ${volumeName}:/target -v ${sourcePath}:/source/${targetName} busybox:latest sh -c 'cp --recursive --update /source/. /target/'")

		println waitForCommand("docker run --rm -v ${volumeName}:/target busybox:latest du -sh /target/${targetName}")

		println "Copied file ${sourcePath} to ${volumeName}"
	}

	executeSQLQuery = {
		String sql, String schema = null ->

		if (!config.useDatabase) {
			throw new GradleException("Database service not detected")
		}

		waitForContainer("database", config.dockerContainerDatabase)

		if (config.useDatabaseMariaDB || config.useDatabaseMySQL) {
			List<String> results = waitForCommand("${getDatabaseAccessCommand(schema)} --batch --execute=\"${sql}\"").split("\n")

			String[] columnHeaders = results[0].split("\t")

			return results.subList(1, results.size()).collect {
				String resultRow ->

				[columnHeaders, resultRow.split("\t")].transpose().collectEntries {
					String[] keyValuePair ->

					[keyValuePair[0], keyValuePair[1]]
				}
			}
		}

		if (config.useDatabasePostgreSQL) {
			if (schema == null || schema.equals(config.databaseName)) {
				schema = "public"
			}

			List<String> results = waitForCommand("${getDatabaseAccessCommand(schema)} --quiet --csv --command=\"${sql}\"").split("\n")

			String[] columnHeaders = results[0].split(",")

			return results.subList(1, results.size()).collect {
				String resultRow ->

				Map<String, String> result = new TreeMap<String, String>(String.CASE_INSENSITIVE_ORDER)

				result.putAll([columnHeaders, resultRow.split(",")].transpose().collectEntries {
					String[] keyValuePair ->

					[keyValuePair[0], keyValuePair[1]]
				})

				return result
			}
		}

		if (config.useDatabaseDB2) {
			List<String> results = waitForCommand("${getDatabaseAccessCommand(schema)} \"${sql}\"").split("\n").minus("")

			results.removeLast()

			String[] columnHeaders = results[0].trim().split(/[ ]+/)

			String[] values = results[results.size()-1].trim().split(/[ ]+/)

			Map<String, String> result = [columnHeaders, values].transpose().collectEntries {
				String[] keyValuePair ->

				[keyValuePair[0], keyValuePair[1]]
			}

			return [result]
		}

		throw new GradleException("Unrecognized database type")
	}

	fixProductVersion = {
		String productVersion ->

		return Util.fixReleaseKey(productVersion)
	}

	forEachCompanyId = {
		Closure<Void> action ->

		List<Map<String, String>> companyVirtualHosts = getCompanyVirtualHosts()

		String defaultWebId = getCompanyDefaultWebId(companyVirtualHosts)

		companyVirtualHosts.each {
			Map<String, String> companyVirtualHost ->

			try {
				String companyIdKey = toTableName("companyId")
				String hostnameKey = toTableName("hostname")
				String webIdKey = toTableName("webId")

				String schema = config.databaseName

				if (config.databasePartitioningEnabled && (companyVirtualHost[webIdKey] != defaultWebId)) {
					schema = "lpartition_${companyVirtualHost[companyIdKey]}"
				}

				action(companyVirtualHost[companyIdKey], companyVirtualHost[hostnameKey], companyVirtualHost[webIdKey], schema)
			}
			catch (Exception e) {
				e.printStackTrace()
			}
		}
	}

	getCompanyVirtualHosts = {
		if (!config.useDatabase || (config.companyVirtualHosts != null)) {
			return config.companyVirtualHosts
		}

		config.companyVirtualHosts = executeSQLQuery("select companyId, hostname, webId from VirtualHost inner join Company using (companyId) where layoutSetId = 0", config.databaseName)

		return config.companyVirtualHosts
	}

	getDatabaseAccessCommand = {
		String schema ->

		if (config.useDatabaseMariaDB || config.useDatabaseMySQL) {
			String command = "docker compose exec -it database mysql --user root"

			if (schema != null) {
				command += " --database=${schema}"
			}

			return command
		}

		if (config.useDatabasePostgreSQL) {
			if (schema == null || schema.equals(config.databaseName)) {
				schema = "public"
			}

			return "docker compose exec -e PGPASSWORD=password -e PGOPTIONS=\"--search_path=${schema}\" -it database psql --username=liferay --dbname=${config.databaseName}"
		}

		if (config.useDatabaseDB2) {
			if (schema == null) {
				schema = config.databaseName
			}

			return [
				"docker compose exec --user db2admin -it database /opt/ibm/db2/V11.5/bin/db2 connect to ${schema} > /dev/null",
				"docker compose exec --user db2admin -it database /opt/ibm/db2/V11.5/bin/db2"
			].join("\n")
		}
	}

	getCompanyDefaultWebId = {
		List<Map<String, String>> companyVirtualHosts ->

		if (!config.useDatabase || (config.defaultCompanyVirtualHost != null) || companyVirtualHosts.isEmpty()) {
			return config.defaultCompanyVirtualHost != null ? config.defaultCompanyVirtualHost["webId"] : null
		}

		String propertyWebId = getPortalPropertyValue("company.default.web.id")

		if (propertyWebId == null) {
			propertyWebId = "liferay.com"
		}

		String webIdKey = toTableName("webId")

		Map<String, String> defaultCompanyVirtualHost = (companyVirtualHosts.size() == 1) ? companyVirtualHosts[0] : null

		if (defaultCompanyVirtualHost == null) {
			defaultCompanyVirtualHost = companyVirtualHosts.find {
				Map<String, String> companyVirtualHost ->

				companyVirtualHost[webIdKey] == propertyWebId
			}
		}

		if (defaultCompanyVirtualHost == null) {
			throw new GradleException("Unable to auto-detect company.default.web.id, please set it in configs/common/portal-ext.properties")
		}

		config.defaultCompanyVirtualHost = defaultCompanyVirtualHost

		return config.defaultCompanyVirtualHost[webIdKey]
	}

	getExistingVolumeNames = {
		String volumeNameLines = waitForCommand("docker volume ls --filter 'name=${config.namespace}_' --format '{{ .Name }}'")

		return volumeNameLines.isEmpty() ? [] : volumeNameLines.split("\n")
	}

	getPortalPropertyValue = {
		String propertyKey, String propertiesFileName = null ->

		String includeAndOverrideValue = null

		if (propertiesFileName == null) {
			includeAndOverrideValue = getPortalPropertyValue(propertyKey, "portal-setup-wizard.properties")

			if (includeAndOverrideValue == null) {
				includeAndOverrideValue = getPortalPropertyValue(propertyKey, "portal-ext.properties")
			}

			if (includeAndOverrideValue == null) {
				includeAndOverrideValue = getPortalPropertyValue(propertyKey, "portal-bundle.properties")
			}

			return includeAndOverrideValue
		}

		File propertiesFile = file("configs/local/${propertiesFileName}")

		if (!propertiesFile.exists()) {
			propertiesFile = file("configs/common/${propertiesFileName}")
		}

		if (!propertiesFile.exists()) {
			return null
		}

		propertiesFile.eachLine {
			String line ->

			line = line.trim()

			if (line.startsWith("include-and-override=")) {
				String includeAndOverrideFileName = line.split("=")[1]

				String newIncludeAndOverrideValue = getPortalPropertyValue(propertyKey, includeAndOverrideFileName)

				if (newIncludeAndOverrideValue != null) {
					includeAndOverrideValue = newIncludeAndOverrideValue
				}
			}
		}

		if (includeAndOverrideValue != null) {
			return includeAndOverrideValue
		}

		propertiesFile.withInputStream {
			BufferedInputStream inputStream ->

			Properties properties = new Properties()

			properties.load(inputStream)

			return properties.getProperty(propertyKey)
		}
	}

	toTableName = {
		String key ->

		if (config.useDatabaseDB2) {
			return key.toUpperCase()
		}

		return key
	}

	updateGradleLocalProperties = {
		Map<String, String> newProperties ->

		File gradleLocalPropertiesFile = file("gradle-local.properties")

		List<String> seenProperties = []
		List<String> gradleLocalPropertiesLines = []

		if (gradleLocalPropertiesFile.exists()) {
			gradleLocalPropertiesLines = gradleLocalPropertiesFile.readLines().collect {
				String line ->

				int pos = line.indexOf('=')

				if (pos == -1) {
					return line
				}

				String key = line.substring(0, pos)

				if (newProperties.containsKey(key)) {
					seenProperties.add(key)
					return "${key}=${newProperties[key]}"
				}

				return line
			}
		}

		gradleLocalPropertiesFile.withOutputStream {
			BufferedOutputStream outputStream ->

			gradleLocalPropertiesLines.each {
				String line ->

				outputStream << line << "\n"
			}

			newProperties.each {
				Map.Entry<String, String> entry ->

				if (!seenProperties.contains(entry.key)) {
					outputStream << entry.key << "=" << entry.value << "\n"
				}
			}
		}
	}

	waitForCommand = {
		String command, File workingDir = null ->

		StringBuffer err = new StringBuffer()
		StringBuffer out = new StringBuffer()

		Process process = ['bash', '-c', command].execute([], workingDir)

		process.waitForProcessOutput(out, err)

		if (process.exitValue() != 0) {
			throw new GradleException("Process exit code ${process.exitValue()}: ${err.toString()}")
		}

		if (err.length() > 0) {
			System.err.println err.toString()
		}

		return out.toString()
	}

	waitForContainer = {
		String serviceName, String containerName ->

		String serviceStatus = waitForCommand("docker compose ps ${serviceName} --format=json").trim()

		if (serviceStatus.length() > 0) {
			JsonSlurper jsonSlurper = new JsonSlurper()

			String health = jsonSlurper.parseText(serviceStatus)["Health"]

			if ((health != null) && health.equals("healthy")) {
				return
			}
		}
		else {
			println "Starting service ${serviceName}"
			waitForCommand("docker compose up -d ${serviceName}")
		}

		String status = ""

		while (!status.equals("\"healthy\"")) {
			if (status != null) {
				Thread.sleep(10000)
			}

			println "Waiting for service ${serviceName}"

			String logs = waitForCommand("docker compose logs ${serviceName} --since=10s")

			if (logs.length() > 0) {
				println logs
			}

			status = waitForCommand("docker inspect --format='{{json .State.Health.Status}}' ${containerName}").trim()
		}
	}
}

tasks.register("testFixProductVersion") {
	doLast {
		[
			["dxp-7.4.u36", "dxp-7.4.u36"],
			["dxp-7.4.u36-lts", "dxp-7.4.u36"],
			["dxp-2024.q1.1", "dxp-2024.q1.1"],
			["dxp-2024.q1.1-lts", "dxp-2024.q1.1"],
			["dxp-2025.q1.1", "dxp-2025.q1.1-lts"],
			["dxp-2025.q1.1-lts", "dxp-2025.q1.1-lts"],
			["dxp-2025.q2.1", "dxp-2025.q2.1"],
			["dxp-2025.q2.1-lts", "dxp-2025.q2.1"],
		].each {
			String[] keyValuePair ->

			String input = keyValuePair[0]
			String expected = keyValuePair[1]

			assert expected == Util.fixReleaseKey(input)
		}
	}
}

tasks.register("runUtilTests") {
	dependsOn ":testFixProductVersion"
}