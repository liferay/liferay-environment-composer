import com.liferay.docker.workspace.environments.Util

import de.undercouch.gradle.tasks.download.Download

import groovy.xml.XmlSlurper
import groovy.xml.slurpersupport.GPathResult

import java.nio.file.Path
import java.nio.file.Paths

project.plugins.apply "docker-common"

configurations {
	db2
	sqlserver
	xerces
	xuggler
}

dependencies {
	db2 group: "com.ibm.db2.jcc", name: "db2jcc", version: "db2jcc4"
	sqlserver group: "com.microsoft.sqlserver", name: "mssql-jdbc", version: "12.10.1.jre11"
	xerces group: "xerces", name: "xercesImpl", version: "2.12.2"
	xuggler group: "xuggle", name: "xuggle-xuggler", version: "5.4"
}

repositories {
	maven {
		url "https://maven.dcm4che.org/"
	}
}

Closure<Boolean> isValidLicenseFile = {
	File licenseFile ->

	String licenseText = licenseFile.text

	if (!licenseText.contains("<license>")) {
		return false
	}

	String invalidLicenseReason = null

	XmlSlurper xmlSlurper = new XmlSlurper()

	GPathResult gPathResult = xmlSlurper.parse(licenseFile)

	if (config.useClustering) {
		String licenseType = gPathResult["license-type"].text()

		if (["developer", "limited", "trial"].contains(licenseType)) {
			invalidLicenseReason = "Clustering is enabled, but ${licenseType} license file ${licenseFile.absolutePath} cannot be used in a clustered environment"
		}
	}

	String expirationDateText = gPathResult["expiration-date"].text()

	if (new Date(expirationDateText).before(new Date())) {
		invalidLicenseReason = "License file ${licenseFile.absolutePath} expired on ${expirationDateText}"
	}

	if (invalidLicenseReason == null) {
		return true
	}

	println invalidLicenseReason

	licenseFile.delete()

	return false
}

Closure<String> getLatestImageName = {
	List<String> dxpImageNames ->

	if (dxpImageNames.isEmpty()) {
		return null
	}

	String latestQuarterlyRelease = dxpImageNames.collect {
		String dxpImageName ->

		dxpImageName.substring(0, dxpImageName.indexOf(".q") + 3)
	}.sort().last()

	String latestQuarterlyReleaseTag = dxpImageNames.findAll {
		String dxpImageName ->

		dxpImageName.startsWith(latestQuarterlyRelease)
	}.sort {
		String a, String b ->

		int aPatch = Integer.parseInt(a.substring(a.indexOf(".q") + 4).split("-")[0])
		int bPatch = Integer.parseInt(b.substring(b.indexOf(".q") + 4).split("-")[0])

		return aPatch - bPatch
	}.last()

	return "liferay/dxp:" + latestQuarterlyReleaseTag
}

Closure<String> getLatestImageNameLocal = {
	String imageName ->

	if ((imageName == null) || !(imageName.contains(".q") || imageName.contains("latest"))) {
		return null
	}

	List<String> dxpImageNames = waitForCommand("docker image ls ${imageName} --format='{{ .Tag }}'").readLines()

	if (dxpImageNames.isEmpty()) {
		dxpImageNames = waitForCommand("docker image ls ${imageName}-* --format='{{ .Tag }}'").readLines()
	}

	return getLatestImageName(dxpImageNames)
}

Closure<FileCollection> copyLiferayLicenseFromDXPImage = {
	String imageName, boolean pullImage = false ->

	if (config.useClustering || (imageName == null) || !(imageName.contains(".q") || imageName.contains("latest"))) {
		return null
	}

	String latestImageName = getLatestImageNameLocal(imageName)

	if (latestImageName == null) {
		if (!pullImage) {
			return null
		}

		println "Checking image ${imageName} for a valid license file to copy, retrieving via docker pull (this may take awhile)"

		waitForCommand("docker pull ${imageName}", null, System.out)

		latestImageName = getLatestImageNameLocal(imageName)

		if (latestImageName == null) {
			return null
		}
	}

	String temporaryContainerName = "${config.namespace}-license-check"
	String temporaryVolumeName = "${config.namespace}-license"

	println "Attempting to copy trial license from ${latestImageName}"

	waitForCommand("docker create --name=${temporaryContainerName} --volume=${temporaryVolumeName}:/opt/liferay/deploy ${latestImageName}")

	File modulesDir = file("${rootProject.projectDir}/configs/common/osgi/modules")

	waitForCommand("docker run --rm -v ${temporaryVolumeName}:/source -v ${modulesDir.absolutePath}:/target alpine sh -c 'cp /source/trial-*.xml /target/'")
	waitForCommand("docker rm ${temporaryContainerName}")
	waitForCommand("docker volume rm ${config.namespace}-license")

	return project.fileTree("configs") {
		include "**/osgi/modules/*.xml"
	}.filter {
		isValidLicenseFile(it)
	}
}

tasks.register("checkForLiferayLicense") {
	onlyIf("using the Liferay service") {
		config.useLiferay
	}
	onlyIf("running Liferay DXP") {
		config.dockerImageLiferayDXP
	}

	doFirst {
		FileCollection licenseXmlFileCollection = project.fileTree("configs") {
			include "**/osgi/modules/*.xml"
		}.filter {
			isValidLicenseFile(it)
		}

		if (Util.isEmpty(licenseXmlFileCollection)) {
			licenseXmlFileCollection = copyLiferayLicenseFromDXPImage(project.gradle.liferayWorkspace.dockerImageLiferay)
		}

		if (Util.isEmpty(licenseXmlFileCollection)) {
			licenseXmlFileCollection = copyLiferayLicenseFromDXPImage("liferay/dxp:*.q*")
		}

		if (Util.isEmpty(licenseXmlFileCollection)) {
			licenseXmlFileCollection = copyLiferayLicenseFromDXPImage("liferay/dxp:latest")
		}

		if (Util.isEmpty(licenseXmlFileCollection)) {
			licenseXmlFileCollection = copyLiferayLicenseFromDXPImage(project.gradle.liferayWorkspace.dockerImageLiferay, true)
		}

		if (Util.isEmpty(licenseXmlFileCollection)) {
			licenseXmlFileCollection = copyLiferayLicenseFromDXPImage("liferay/dxp:latest", true)
		}

		if (Util.isEmpty(licenseXmlFileCollection)) {
			if (config.useClustering) {
				throw new GradleException("Please add a non-expired license that allows for clustering to configs/common/osgi/modules/")
			}

			throw new GradleException("Please add a non-expired license to configs/common/osgi/modules/")
		}
	}
}

Configuration dbDriverConfiguration = configurations.findByName(config.databaseType)

tasks.register("prepareJDBCDriver", Copy) {
	onlyIf("using the Liferay service") {
		config.useLiferay
	}
	onlyIf("there is a database driver to install") {
		dbDriverConfiguration != null
	}

	from {
		dbDriverConfiguration
	}
	into "configs/common/tomcat/webapps/ROOT/WEB-INF/shielded-container-lib"
}

tasks.register("prepareSAXParser", Copy) {
	onlyIf("using the Liferay service") {
		config.useLiferay
	}
	onlyIf("using Amazon S3 store") {
		config.dlStore == "s3"
	}

	from configurations.xerces

	into "configs/common/tomcat/webapps/ROOT/WEB-INF/shielded-container-lib"
}

tasks.register("prepareXugglerJar", Copy) {
	onlyIf("using the Liferay service") {
		config.useLiferay
	}
	onlyIf("media preview is enabled") {
		config.mediaPreviewEnabled
	}
	onlyIf("specifying a workspace product version for Liferay 7.3 or older") {
		!config.is74OrQuarterly
	}

	from {
		configurations.findByName("xuggler")
	}
	into "configs/common/tomcat/webapps/ROOT/WEB-INF/lib"
}

tasks.register("validateHotfixURLs") {
	onlyIf("using the Liferay service") {
		config.useLiferay
	}
	onlyIf("specifying a workspace product version for Liferay 7.4 or later") {
		config.product != null && config.product.startsWith("dxp-") &&
		(config.product.startsWith("dxp-7.4-") || config.product.contains(".q"))
	}

	doFirst {
		String liferayVersion = config.product.substring(4)

		if (liferayVersion.startsWith("7.4-")) {
			liferayVersion = "7.4.13-${liferayVersion.substring(4)}"
		}

		String mismatchedHotfixURL = config.hotfixURLs.find {
			String hotfixURL ->

			!hotfixURL.contains("/${liferayVersion}/")
		}

		if (mismatchedHotfixURL != null) {
			throw new GradleException("Hotfix ${mismatchedHotfixURL} does not match Liferay workspace product version ${config.product}")
		}
	}
}

tasks.register("deleteStaleHotfixes") {
	doFirst {
		List<String> hotfixURLs = config.gcpHotfixURLs + config.hotfixURLs

		Set<String> hotfixNames = hotfixURLs.collect {
			Path path = Paths.get(new URI(it).path)
			return path.getName(path.nameCount - 1).toString()
		}.toSet()

		if (hotfixNames.isEmpty()) {
			hotfixNames = project.fileTree("configs") {
				include "**/patching/liferay*hotfix*.zip"
			}.collect {
				File hotfixFile ->

				hotfixFile.name
			}.toSet()
		}

		project.fileTree(".") {
			include "build/docker/configs/**/patching/liferay*hotfix*.zip"
			include "configs/**/patching/liferay*hotfix*.zip"
		}.filter {
			File hotfixFile ->

			!hotfixNames.contains(hotfixFile.name)
		}.each {
			File hotfixFile ->

			println "Deleting stale hotfix ${hotfixFile.absolutePath}"
			hotfixFile.delete()
		}
	}
}

tasks.register("prepareHotfixesGCP") {
	onlyIf("there are GCP hotfix URLs") {
		!config.gcpHotfixURLs.isEmpty()
	}
	onlyIf("using the Liferay service") {
		config.useLiferay
	}

	mustRunAfter validateHotfixURLs

	doFirst {
		if (!isProgramInstalled("gcloud")) {
			throw new GradleException("The gcloud CLI must be installed in order to download hotfixes from GCP. Follow the install instructions at https://docs.cloud.google.com/sdk/docs/install.")
		}

		try {
			waitForCommand("gcloud auth print-access-token")
		}
		catch (Exception e) {
			waitForCommand("gcloud auth login")
		}

		config.gcpHotfixURLs.forEach {
			String hotfixURL ->

			waitForCommand("gcloud storage cp --no-clobber ${hotfixURL} configs/common/patching/")
		}
	}
}

tasks.register("prepareHotfixesNonGCP", Download) {
	onlyIf("there are non-GCP hotfix URLs") {
		!config.hotfixURLs.isEmpty()
	}
	onlyIf("using the Liferay service") {
		config.useLiferay
	}

	mustRunAfter validateHotfixURLs

	dest project.layout.dir(project.provider {project.file("configs/common/patching")})

	overwrite false

	src config.hotfixURLs
}

tasks.register("prepareHotfixes") {
	onlyIf("using the Liferay service") {
		config.useLiferay
	}

	dependsOn validateHotfixURLs

	dependsOn prepareHotfixesGCP
	dependsOn prepareHotfixesNonGCP

	finalizedBy deleteStaleHotfixes
}

tasks.register("fixWorkspaceProduct") {
	onlyIf("product is set") {
		config.product != null
	}

	doLast {
		config.product = Util.fixReleaseKey(config.product)

		if (!config.product.equals(project.gradle.liferayWorkspace.product)) {
			project.updateGradleLocalProperties([
				"liferay.workspace.product": config.product
			])

			project.gradle.liferayWorkspace.product = config.product
		}
	}
}

verifyProduct.dependsOn fixWorkspaceProduct

tasks.register("listAdminUsers") {
	onlyIf("using an external database") {
		config.useDatabase
	}
	onlyIf("database is not empty") {
		!Util.isEmpty(project.fileTree("dumps")) || !Util.isEmpty(project.fileTree(config.dataDirectory)) || config.useLiferay
	}

	Closure<Void> listAdminUsersForCompany = {
		String companyId, String hostname, String webId, String schema ->

		String tcp8080Port = waitForCommand("docker compose ps liferay --format '{{range .Publishers}}{{if and (eq .URL \"0.0.0.0\") (eq .TargetPort 8080)}}{{.PublishedPort}}{{end}}{{end}}'")

		List results = executeSQLQuery("select screenName, emailAddress from User_ where companyId = ${companyId} and userId in (select userId from Users_Roles where roleId in (select roleId from Role_ where name = 'Administrator'))", schema)

		println "\nhttp://${hostname}:${tcp8080Port}/c/portal/login"
		println "http://${hostname}:${tcp8080Port}/?p_p_id=com_liferay_login_web_portlet_LoginPortlet&p_p_lifecycle=0&p_p_state=exclusive&p_p_mode=view&_com_liferay_login_web_portlet_LoginPortlet_mvcRenderCommandName=%2Flogin%2Flogin&saveLastPath=false"
		println getDatabaseAccessCommand(schema)

		if (results.isEmpty()) {
			println "Unable to detect users explicitly granted the Administrator role"
		}
		else {
			println "Detected the following users explicitly granted the Administrator role"

			results.each {
				Map<String, String> resultRow ->

				println " - ${resultRow["screenName"]} (${resultRow["emailAddress"]})"
			}
		}
	}

	doFirst {
		forEachCompanyId listAdminUsersForCompany
	}
}

tasks.register("exportLiferayLogs", Exec) {
	onlyIf("using the Liferay service") {
		config.useLiferay
	}

	executable project.file("scripts/export_liferay_logs.sh")
}

tasks.register("printBundleInfo", Exec) {
	onlyIf("using the Liferay service") {
		config.useLiferay
	}

	environment("LIFERAY_PRODUCT", config.dockerImageLiferayDXP ? "dxp" : "portal")
	environment("LIFERAY_VERSION", gradle.liferayWorkspace.targetPlatformVersion)

	executable project.file("scripts/print_bundle_info.sh")
}

tasks.register("downloadYourKitAgentZip", Download) {
	onlyIf("using YourKit") {
		config.yourKitEnabled
	}

	dest layout.buildDirectory.file("downloadYourKitAgentZip/YourKit.zip")

	overwrite true

	src config.yourKitUrl
}

tasks.register("prepareYourKitAgent", Copy) {
	onlyIf("using YourKit") {
		config.yourKitEnabled
	}

	dependsOn ":downloadYourKitAgentZip"

	eachFile {
		File file ->

		file.relativePath = RelativePath.parse(true, file.name)
	}

	from zipTree(downloadYourKitAgentZip.dest)

	if (config.isARM) {
		include "**/linux-arm-64/libyjpagent.so"
	}
	else {
		include "**/linux-x86-64/libyjpagent.so"
	}

	includeEmptyDirs false
	into "configs/common/yourkit"
}